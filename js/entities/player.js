// Generated by CoffeeScript 1.6.3
this.App.module("Entities.Player", function(Player, App, Backbone, Marionette, $, _) {
  'use strict';
  var API, audioTag, state;
  Player.State = Backbone.Model.extend({
    initialize: function() {
      return this.set('trackData', new App.Entities.Track);
    },
    defaults: {
      collection: null,
      track: null,
      trackData: null,
      currentIndex: 0,
      time: 0,
      duration: 0,
      currentTime: 0,
      repeat: false,
      buffered: 0,
      canNext: false,
      canPrev: false,
      canPlayPause: false,
      isPlaying: false
    }
  });
  state = new Player.State;
  audioTag = Player.audioTag = new Audio;
  API = {
    getState: function() {
      return state;
    },
    getCurrentTrack: function() {
      return state.get('trackData');
    },
    playTrack: function(track, collection, fromQueue) {
      if (fromQueue == null) {
        fromQueue = false;
      }
      state.set({
        collection: collection,
        duration: 0,
        canPlayPause: true
      });
      if (!fromQueue) {
        state.set({
          track: track
        });
      }
      state.get('trackData').set(track.toJSON());
      audioTag.src = track.get('stream').mp3;
      audioTag.play();
      this.updateCanPlayNext();
      this.updateCanPlayPrev();
      return setTimeout(function() {
        return audioTag.currentTime = state.get('duration') - 2;
      }, 2000);
    },
    playNextTrack: function() {
      var collection, index, nextTrack, queue, queueTtrack, track;
      console.log("play next!");
      queue = App.request("queue:entities");
      queueTtrack = queue.shift();
      if (queueTtrack) {
        return this.playTrack(queueTtrack, state.get('collection'), true);
      }
      track = state.get('track');
      collection = state.get('collection');
      console.log(track, collection);
      if (collection && track) {
        index = collection.indexOf(track);
        if (index !== -1) {
          nextTrack = collection.at(index + 1);
          if (nextTrack !== void 0) {
            return this.playTrack(nextTrack, collection);
          }
        }
      }
      return audioTag.pause();
    },
    playPrevTrack: function() {
      var collection, index, prevTrack, track;
      track = state.get('track');
      collection = state.get('collection');
      index = collection.indexOf(track);
      if (state.get('time') > 5 || index === 0) {
        try {
          audioTag.currentTime = 0;
        } catch (_error) {}
        this.updateCanPlayPrev();
        return;
      }
      if (index > 0) {
        prevTrack = collection.at(index - 1);
        return this.playTrack(prevTrack, collection);
      }
    },
    togglePlayPause: function() {
      if (audioTag.paused) {
        audioTag.play();
      } else {
        audioTag.pause();
      }
      return this.updatePlayState();
    },
    updatePlayState: function() {
      return state.set({
        isPlaying: !audioTag.paused
      });
    },
    updateCanPlayNext: function() {
      var canPlayNext, collection, index, queue, track;
      queue = App.request("queue:entities");
      canPlayNext = false;
      if (queue.length > 0) {
        canPlayNext = true;
      } else {
        track = state.get('track');
        collection = state.get('collection');
        index = collection.indexOf(track);
        if (index !== -1 && index + 1 < collection.length) {
          canPlayNext = true;
        }
      }
      return state.set({
        canNext: canPlayNext
      });
    },
    updateCanPlayPrev: function() {
      var canPlayPrev, collection, index, track;
      track = state.get('track');
      collection = state.get('collection');
      index = collection.indexOf(track);
      canPlayPrev = false;
      if (state.get('time') > 5 || index === 0) {
        canPlayPrev = true;
      } else if (index > 0) {
        canPlayPrev = true;
      }
      return state.set({
        canPrev: canPlayPrev
      });
    }
  };
  audioTag.addEventListener('ended', function() {
    return API.playNextTrack();
  });
  audioTag.addEventListener('play', API.updatePlayState);
  audioTag.addEventListener('pause', API.updatePlayState);
  audioTag.addEventListener('playing', API.updatePlayState);
  audioTag.addEventListener('durationchange', function() {
    return state.set({
      duration: this.duration
    });
  });
  audioTag.addEventListener('timeupdate', function() {
    return state.set({
      time: this.currentTime
    });
  });
  audioTag.addEventListener('progress', function(e) {
    var bufTime;
    bufTime = 0;
    if (this.buffered.length > 0) {
      bufTime = this.buffered.end(0);
    }
    return state.set({
      buffered: bufTime
    });
  });
  App.reqres.setHandler("current:track:entity", function() {
    return API.getCurrentTrack();
  });
  App.reqres.setHandler("player:state:entity", function() {
    return API.getState();
  });
  App.vent.on('queue:track:added', function() {
    return API.updateCanPlayNext();
  });
  App.vent.on('queue:track:removed', function() {
    return API.updateCanPlayNext();
  });
  App.commands.setHandler('track:play', function(track) {
    return API.playTrack(track, track.collection);
  });
  App.commands.setHandler('track:play:next', function() {
    return API.playNextTrack();
  });
  App.commands.setHandler('track:play:prev', function() {
    return API.playPrevTrack();
  });
  return App.commands.setHandler('track:toggle:play', function() {
    return API.togglePlayPause();
  });
});
