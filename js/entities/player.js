// Generated by CoffeeScript 1.6.3
this.App.module("Entities.Player", function(Player, App, Backbone, Marionette, $, _) {
  'use strict';
  var API, aacSource, audioTag, mp3Source, oggSource, state;
  Player.State = Backbone.Model.extend({
    initialize: function() {
      return this.set('trackData', new App.Entities.Track);
    },
    defaults: {
      collection: null,
      track: null,
      trackData: null,
      currentIndex: 0,
      time: 0,
      duration: 0,
      currentTime: 0,
      repeat: false,
      buffered: 0,
      canNext: false,
      canPrev: false,
      canPlayPause: false,
      isPlaying: false
    }
  });
  state = new Player.State;
  audioTag = Player.audioTag = new Audio;
  mp3Source = document.createElement('source');
  mp3Source.type = "audio/mp3";
  audioTag.appendChild(mp3Source);
  oggSource = document.createElement('source');
  oggSource.type = "audio/ogg; codecs=vorbis";
  audioTag.appendChild(oggSource);
  aacSource = document.createElement('source');
  aacSource.type = "audio/aac";
  audioTag.appendChild(aacSource);
  API = {
    getState: function() {
      return state;
    },
    getCurrentTrack: function() {
      return state.get('trackData');
    },
    playTrack: function(track, collection, fromQueue, doPlay) {
      var isPlaying;
      if (fromQueue == null) {
        fromQueue = false;
      }
      if (doPlay == null) {
        doPlay = false;
      }
      state.set({
        collection: collection,
        duration: 0,
        canPlayPause: true,
        buffered: 0,
        time: 0
      });
      if (!fromQueue) {
        state.set({
          track: track
        });
      }
      state.get('trackData').set(track.toJSON());
      isPlaying = !audioTag.paused;
      aacSource.src = track.get('stream').aac;
      mp3Source.src = track.get('stream').mp3;
      oggSource.src = track.get('stream').vorbis;
      audioTag.load();
      if (isPlaying || doPlay) {
        audioTag.play();
      }
      this.updateCanPlayNext();
      return this.updateCanPlayPrev();
      /*setTimeout ->
      				audioTag.currentTime = state.get('duration')-2
      			, 2000
      */

    },
    playNextTrack: function(automatic) {
      var collection, index, nextTrack, queue, queueTtrack, track;
      if (automatic == null) {
        automatic = false;
      }
      queue = App.request("queue:entities");
      queueTtrack = queue.shift();
      if (queueTtrack) {
        return this.playTrack(queueTtrack, state.get('collection'), true, automatic);
      }
      track = state.get('track');
      collection = state.get('collection');
      if (collection && track) {
        index = collection.indexOf(track);
        if (index !== -1) {
          nextTrack = collection.at(index + 1);
          if (nextTrack !== void 0) {
            return this.playTrack(nextTrack, collection, false, automatic);
          } else if (state.get('repeat')) {
            nextTrack = collection.at(0);
            if (nextTrack !== void 0) {
              return this.playTrack(nextTrack, collection, false, automatic);
            }
          }
        }
      }
      return audioTag.pause();
    },
    playPrevTrack: function() {
      var collection, index, prevTrack, track;
      track = state.get('track');
      collection = state.get('collection');
      if (track && collection) {
        index = collection.indexOf(track);
        if (state.get('time') > 5 || (index === 0 && !state.get('repeat'))) {
          try {
            audioTag.currentTime = 0;
          } catch (_error) {}
          this.updateCanPlayPrev();
          return;
        }
        if (index > 0) {
          prevTrack = collection.at(index - 1);
          return this.playTrack(prevTrack, collection);
        } else if (state.get('repeat')) {
          prevTrack = collection.at(collection.length - 1);
          return this.playTrack(prevTrack, collection);
        }
      } else if (state.get('canPlayPause')) {
        try {
          audioTag.currentTime = 0;
        } catch (_error) {}
        return this.updateCanPlayPrev();
      }
    },
    togglePlayPause: function() {
      if (audioTag.paused) {
        audioTag.play();
      } else {
        audioTag.pause();
      }
      return this.updatePlayState();
    },
    setRepeatMode: function(enabled) {
      state.set({
        repeat: enabled
      });
      return this.updateCanPlayNext();
    },
    seek: function(time) {
      try {
        return audioTag.currentTime = time;
      } catch (_error) {}
    },
    updatePlayState: function() {
      return state.set({
        isPlaying: !audioTag.paused
      });
    },
    updateCanPlayNext: function() {
      var canPlayNext, collection, index, queue, track;
      queue = App.request("queue:entities");
      canPlayNext = false;
      if (queue.length > 0) {
        canPlayNext = true;
      } else {
        track = state.get('track');
        collection = state.get('collection');
        if (track && collection) {
          index = collection.indexOf(track);
          if (index !== -1 && index + 1 < collection.length) {
            canPlayNext = true;
          } else if (state.get('repeat')) {
            canPlayNext = true;
          }
        }
      }
      return state.set({
        canNext: canPlayNext
      });
    },
    updateCanPlayPrev: function() {
      return state.set({
        canPrev: state.get('canPlayPause')
      });
    }
  };
  audioTag.addEventListener('ended', function() {
    return API.playNextTrack(true);
  });
  audioTag.addEventListener('play', API.updatePlayState);
  audioTag.addEventListener('pause', API.updatePlayState);
  audioTag.addEventListener('playing', API.updatePlayState);
  audioTag.addEventListener('durationchange', function() {
    return state.set({
      duration: this.duration
    });
  });
  audioTag.addEventListener('timeupdate', function() {
    return state.set({
      time: this.currentTime
    });
  });
  audioTag.addEventListener('progress', function(e) {
    var bufTime;
    bufTime = 0;
    if (this.buffered.length > 0) {
      bufTime = this.buffered.end(0);
    }
    return state.set({
      buffered: bufTime
    });
  });
  App.reqres.setHandler("current:track:entity", function() {
    return API.getCurrentTrack();
  });
  App.reqres.setHandler("player:state:entity", function() {
    return API.getState();
  });
  App.vent.on('queue:track:added', function() {
    return API.updateCanPlayNext();
  });
  App.vent.on('queue:track:removed', function() {
    console.log("queue changed");
    return API.updateCanPlayNext();
  });
  App.commands.setHandler('track:play', function(track) {
    return API.playTrack(track, track.collection, false, true);
  });
  App.commands.setHandler('track:play:next', function() {
    return API.playNextTrack();
  });
  App.commands.setHandler('track:play:prev', function() {
    return API.playPrevTrack();
  });
  App.commands.setHandler('track:toggle:play', function() {
    return API.togglePlayPause();
  });
  App.commands.setHandler('track:seek', function(time) {
    return API.seek(time);
  });
  return App.commands.setHandler('repeat:enable', function(enabled) {
    return API.setRepeatMode(enabled);
  });
});
